# 🧮 Calculator Project — Study Notes

이번 과제에서는 간단한 **사칙연산 계산기**를 Python으로 구현했다.  
주어진 답안 코드와 내가 작성한 코드를 비교하면서, 파이썬적인 구현 방식과 개선할 점을 배우게 되었다.  

---

## 📌 답안 코드의 특징
- **연산 함수들을 딕셔너리에 함수 자체로 저장**하고, 나중에 `()`로 실행하는 구조
- `calculator()` 함수를 정의하여 재귀적으로 다시 호출 → 계산기 초기화 가능
- 함수 단위로 로직이 잘 캡슐화되어 있어 **가독성**과 **재사용성**이 좋음

```python
operations = {
    "+": add,
    "-": subtract,
    "*": multiply,
    "/": divide,
}
answer = operations[operation_symbol](num1, num2)
```

## 📌 내가 작성한 코드의 특징

while True: 루프로 전체 흐름을 제어

last_number라는 변수를 두어 이전 결과를 이어받아 계산 가능

연산을 딕셔너리에 "결과값"으로 저장 → 불필요한 계산이 모두 실행됨

```python
keys = {"+": add(number1, number2),
        "-": subtract(number1, number2),
        "*": multiply(number1, number2),
        "/": divide(number1, number2)}
result = keys[operation]
```
--- 

## ⚖️ 비교 정리
| 구분 | 답안 코드 | 내가 작성한 코드 |
|------|-----------|------------------|
| 연산 저장 | 함수 자체(`+`: add) | 함수 실행 결과 (`+`: add(n1, n2)) |
| 실행 방식 | 재귀 함수 호출 | 무한 루프 + 상태 변수 |
| 구조 | 함수형, 모듈화 | 절차적, 전역 제어 |
| 장점 | 확장성, 가독성 | 직관적, 단순 | 
| 단점 | 재귀 스택 증가 가능 | 불필요한 연산 실행, 유지보수 어려움 |

---

## 🔧 개선할 점

내 코드에서 가장 크게 개선할 부분은 딕셔너리에 결과값이 아닌 함수 자체를 저장하는 것이다.

👉 개선된 코드 예시:
```python
keys = {"+": add, "-": subtract, "*": multiply, "/": divide}
result = keys[operation](number1, number2)
```
이렇게 하면 필요할 때만 해당 연산이 실행되므로 더 효율적이고 파이써닉한 구조가 된다.

---

## 💡 깨달은 점
1.함수를 값처럼 다룰 수 있다는 점이 파이썬의 강력한 장점이라는 걸 알았다.

2.무한 루프 방식도 직관적이지만, 함수형 구조가 더 깔끔하고 유지보수가 쉽다는 걸 느꼈다.

3.코드가 돌아가는 것에 만족하지 않고, 효율성과 확장성을 고려해야 한다는 점을 배웠다.